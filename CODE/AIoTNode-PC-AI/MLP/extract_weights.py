"""
Extract weights and biases from ONNX model for MCU deployment
This script extracts the trained weights from iris_mlp.onnx and generates C++ header files
"""

import onnx
import numpy as np
import onnxruntime as ort

def extract_onnx_weights(onnx_path='iris_mlp.onnx'):
    """Extract weights and biases from ONNX model"""
    # Load ONNX model
    model = onnx.load(onnx_path)
    
    # Get initializers (weights and biases)
    initializers = {}
    for init in model.graph.initializer:
        initializers[init.name] = np.frombuffer(init.raw_data, dtype=np.float32).reshape(init.dims)
    
    # Print model structure
    print("Model Structure:")
    print("=" * 60)
    for node in model.graph.node:
        print(f"Node: {node.name}, Type: {node.op_type}")
        for i, input_name in enumerate(node.input):
            if input_name in initializers:
                shape = initializers[input_name].shape
                print(f"  Input {i}: {input_name}, Shape: {shape}, Size: {initializers[input_name].size}")
    
    return initializers

def generate_cpp_header(initializers, output_path='iris_mlp_weights.h'):
    """Generate C++ header file with weights and biases"""
    
    # Map ONNX layer names to our layer indices
    # Based on the model: fc1 (4->16), fc2 (16->8), fc3 (8->3)
    layer_mapping = {
        'fc1.weight': (0, 'weights'),  # Layer 0 weights
        'fc1.bias': (0, 'bias'),       # Layer 0 bias
        'fc2.weight': (1, 'weights'),  # Layer 1 weights
        'fc2.bias': (1, 'bias'),       # Layer 1 bias
        'fc3.weight': (2, 'weights'),  # Layer 2 weights
        'fc3.bias': (2, 'bias'),       # Layer 2 bias
    }
    
    # Try to find the actual names in the model
    actual_names = {}
    for name in initializers.keys():
        if 'weight' in name.lower() or 'bias' in name.lower():
            # Try to match
            for key, value in layer_mapping.items():
                if key.split('.')[0] in name.lower():
                    actual_names[name] = value
                    break
    
    # If not found, use order-based mapping
    if not actual_names:
        sorted_names = sorted(initializers.keys())
        layer_idx = 0
        weight_found = False
        for name in sorted_names:
            arr = initializers[name]
            if len(arr.shape) == 2:  # Weight matrix
                actual_names[name] = (layer_idx, 'weights')
                weight_found = True
            elif len(arr.shape) == 1 and weight_found:  # Bias vector (after weight)
                actual_names[name] = (layer_idx, 'bias')
                layer_idx += 1
                weight_found = False
    
    # Generate C++ header
    with open(output_path, 'w') as f:
        f.write("""/**
 * @file iris_mlp_weights.h
 * @brief Extracted weights and biases from trained Iris MLP model
 * @note This file is auto-generated by extract_weights.py
 * @warning Do not edit this file manually
 */

#pragma once

#include <stdint.h>

""")
        
        # Write weights and biases for each layer
        for layer_idx in range(3):  # 3 layers: fc1, fc2, fc3
            # Find weights and bias for this layer
            weights_name = None
            bias_name = None
            
            for name, (idx, param_type) in actual_names.items():
                if idx == layer_idx:
                    if param_type == 'weights':
                        weights_name = name
                    elif param_type == 'bias':
                        bias_name = name
            
            if weights_name:
                weights = initializers[weights_name]
                # ONNX stores weights in (out_features, in_features) format
                # Our MLP expects: output = weights * input + bias
                # So weights should be (out_features, in_features)
                if len(weights.shape) == 2:
                    rows, cols = weights.shape
                elif len(weights.shape) == 1:
                    # Handle 1D case (shouldn't happen for weights, but handle it)
                    rows = weights.shape[0]
                    cols = 1
                else:
                    print(f"Warning: Unexpected weight shape {weights.shape} for {weights_name}")
                    continue
                
                f.write(f"// Layer {layer_idx} weights: {rows} x {cols}\n")
                f.write(f"static const float iris_mlp_weights_layer{layer_idx}[] = {{\n")
                for i in range(rows):
                    f.write("    ")
                    for j in range(cols):
                        f.write(f"{weights[i, j]:.8f}f")
                        if j < cols - 1:
                            f.write(", ")
                    if i < rows - 1:
                        f.write(",\n")
                f.write("\n};\n\n")
            
            if bias_name:
                bias = initializers[bias_name]
                size = bias.shape[0]
                
                f.write(f"// Layer {layer_idx} bias: {size}\n")
                f.write(f"static const float iris_mlp_bias_layer{layer_idx}[] = {{\n")
                f.write("    ")
                for i in range(size):
                    f.write(f"{bias[i]:.8f}f")
                    if i < size - 1:
                        f.write(", ")
                f.write("\n};\n\n")
        
        f.write("""// Network architecture
#define IRIS_MLP_INPUT_SIZE  4
#define IRIS_MLP_HIDDEN1_SIZE 16
#define IRIS_MLP_HIDDEN2_SIZE 8
#define IRIS_MLP_OUTPUT_SIZE 3

// Layer sizes array for MLP constructor
static const int iris_mlp_layer_sizes[] = {
    IRIS_MLP_INPUT_SIZE,
    IRIS_MLP_HIDDEN1_SIZE,
    IRIS_MLP_HIDDEN2_SIZE,
    IRIS_MLP_OUTPUT_SIZE
};

""")
    
    print(f"\nC++ header file generated: {output_path}")

def main():
    print("Extracting weights from ONNX model...")
    initializers = extract_onnx_weights()
    
    print("\nGenerating C++ header file...")
    generate_cpp_header(initializers)
    
    print("\nDone!")

if __name__ == '__main__':
    main()

